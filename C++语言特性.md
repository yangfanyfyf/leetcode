## C++语言特性

1. 左值与右值

   左值：表达式结束后依然存在的持久对象

   右值：表达式结束就不再存在的临时对象

   `std::move`可以将左值强制转换为右值

   

2. Std::move

   将有名字的变量（左值）转换为无名的右值引用。

   ```C++
   string s = "fuck"; //-1
   string &&rs = std::move(s); //-2
   ```

   -2中使用move将s转换成右值引用并绑定给rs，没有执行实际的移动操作。

   ```C++
   string s = "fuck";//-1
   string s2;        //-2
   s2 = std::move(s);//-3
   ```

   这样s就会被移动，s2接管了s的资源。

   

3. 指针

   大小：在64位计算机中，占用8个字节

   有5种：

   + 指向普通变量的指针
   + 指向常量对象的指针
   + 指向函数的指针
   + 指向对象成员的指针，需要指定类
   + this指针，指向类当前对象的指针常量



4. 野指针和悬空指针

   野指针：是不确定其指向的指针，例如未初始化的指针

   悬空指针：指向一块已经被释放的内存空间



5. NULL和nullptr的区别

   NULL，预处理变量，是一个宏，他的值是0，定义在<cstdlib>中

   nullptr，C++11中的关键字，是一种特殊类型的字面值

   NULL的本质是0，所以可能会在函数重载的过程中发生问题。



6. 指针和引用的区别

   指针指向的内存可以改变，但是引用所绑定的对象一旦绑定就不能改变

   指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占空间

   指针可以为空，但是引用必须绑定对象

   指针可以有多级，但是引用只能有一级

   

7. 常量指针和指针常量的区别

   常量指针，本质上是一个指针，但是指向常量。const位于*左侧。

   指针常量，指针自身是一个常量，所以指向的位置不能改变，但是可以通过这个指针修改变量。*在const的左侧。



8. 函数指针和指针函数

   函数指针，本质上是一个指针，这个指针指向一个函数。需要指定同样的参数，同样的返回类型。

   ```C++
   int fun1(int tmp1, int tmp2){}
   int main(){
   	int (*fun)(int x, int y)
   }
   ```

   指针函数，本质是一个函数，但是返回值是一个指针。两者的定义也不相同。

   ```C++
   int* fun(int x, int y);
   ```

   

9. 强制转换的种类

   语法：四种转换的语法相同：

   ```C++
   xxx_cast<new>(data)
   ```

   + `static_cast`用于数据的强制类型转换，风险低

     例如short转int，int转double，const转非const

   + `const_cast`去掉常量属性，不能去除变量的常量性，只能去除指针或者引用的常量性

   + `reinterpret_cast`改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。只是对于二进制位的重新解释，风险大。

   + `dynamic_cast`只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，可以向上或者向下进行转换，也就是父类子类之间的转换。



10. 如何判断结构体是否相等？可以使用memcmp吗？

    需要重载操作符==用以判断是否相等。

    memcmp不能使用，因为这个函数是逐个字节进行比较的，而结构体之中存在字节对齐，对齐时补全的字节内容是随机的，所以无法比较。



11. 值传递，引用传递，指针传递的区别？

    值传递，形参是实参的拷贝，函数对于形参的操作不会影响到实参。

    指针传递，本质上是值传递，只不过拷贝的是指针的值，可以通过指针修改指向的对象。

    引用传递























